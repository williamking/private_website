# 变量的解构赋值

## 基本结构
```
var [a,b,c] = [1,2,3]
```
相当于
```
var a = 1;
var b = 2;
var c = 3;
```
### 解构失败的情况：
解构失败，赋值结果为undefined,以下为失败情况：
1）等号右边不是可遍历的结构:
```
let [foo] = 1; //undefined
```

2)等号两边结构不配对(数组或对象层次结构对比)
```
let [foo] = {} //undefined
```

3)对已声明的变量进行解购赋值
```
var x;
{x} = {x: 1};
//错误
```
javascript引擎会将等好左边部分看成一个代码快，从而产生语法错误，因此对于已声明的变量的解构赋值，需要将整个语句用括号括起：
code:
```
var x;
({x} = {x: 1});
```

不完全结构:
此情况解构仍会成功

1.多余：
```
var [x, y] = [1, 2, 3];
```

2.缺少:
```
var [x, y] = [1]; //[1, undefined]
```
这种情况我的理解是将解构赋值看成一层层的递归赋值，最外层[x,y] = [1]是成功的，而内层对y的赋值是失败的(没有对应的值)，因此算是局部失败的解构赋值情况.

可以使用解构赋值的条件：具有Iterator接口

## 默认值指定
如下例:
```
let [x, y = 'b'] = ['a'];
// x = 'a', y = 'b'
```
注意默认值生效的条件是该变量原本应为undefined

## 对象结构赋值
```
var {a, b} = {a : 1, b: 2}
// a = 1, b = 2
```
根据键值与变量名匹配来赋值
若变量名与键不一致，则用下面的方法:
```
var {a: x} = {a : 1}
// x = 1
```
等号左边对象的键只是模式，不代表真正的变量，其对应的值才是变量名

## 字符串的解构赋值

字符串进行解构赋值时，会被当成一个数组对象处理:
`
let [a,b,c,d,e] = 'hello';
a //'h'
b //'e'
c //'l'
d //'l'
e //'o'
`
由于数组对象具有length属性，因此也可用于解构赋值

## 数值和布尔值的解构赋值

同样，会转成对象处理，对象内的属性方法都可进行解构赋值，如toString


## 函数参数的解构赋值

将其看作是 形参 = 实参的解构赋值语句来分析即可,如：

```
function foo({x, y}) {
}
foo({x: 2, y: 3});
//相当于 {x, y} = {x: 2, y: 3};
```

但有一点要注意的是默认值的解构问题，前面有说过，只有原本变量应为undefined(可看成是解构失败）时，才会触发默认值的赋值，因此只需要看清楚默认值等号左边的是什么，原本是否为undefined，就可知道它是否为默认值了,也就是像之前写的我对不完全赋值的理解一样，从外到内一层层分析：

```
function foo({x = 0, y = 0} = {}) {
    return [x, y];
}
foo({}); //[0, 0]
//首先看最外层对象的赋值，这一层对实参"{}"的解构是成功的，因此默认值没有触发，即使默认值也是"{}"
//然后看里面的每一个属性的解构，由于实参是空对象，解构得x,y都为undefined，因此触发了x,y的默认值，所以最后x, y的值为0

foo({x : 3}); //[3, 0]
//最外层同前面分析，未触发默认值，赋值为实参{x : 3}
//内层属性赋值，只有y没有对应值，赋值失败，值为undefined，触发其默认值赋值，因此最后结果x = 3, y = 0
```

下面再给出一个例子：
```
function foo({x, y = 3} = {x: 0}) {
    return [x, y];
}
foo(); //[0, 3]
```
在这个例子中，只存在最外层对象的默认值，因此只有最外层对象为undefined时才会触发默认值的赋值,所以只有使外层对象赋值失败,即不传入实参或者传入undefined，使最默认值的赋值才会触发.
触发默认值赋值时，由于默认值赋值是一个解构赋值，因此看内层的赋值,x有对应的值0，所以赋值为0,而y没有对应值，赋值失败，值为undefined，刚好y本身有默认值的设定，
因此又触发了y的默认值赋值，y的值为3。因此要分清楚x和y的值来源是不一样的。
