template <class Record>

struct Node

{

         Record entry;

         Node<Record> *next;

};

 

template <class Record>

class Sortable_list

{

public:

         Sortable_list() {
           head = 0;
         }

         ~Sortable_list() {
           while (head != 0) {
             Node p = head;
             head = head->next;
             delete p;
           }
           head = 0;
         }

       

         // 在第position个位置插入值为entry的元素，如果position为0则插入在链表头，以此类推

         // 输入数据中，position满足 0 <= position <= 链表元素数量

         void insert(int position, const Record &entry) {
           if (positon == 0) {
             Node *new_node = new Node(entry, head);
             head = new_node;
           } else {
             Node *p = head;
             for (int i = 1; i <= position - 1; ++i) p = p->next;
             Node *new_node = new Node(entry, p->next);
             p->next = new_node;
           }
         }

 

         // 输出链表的内容，每两个元素之间用一个空格隔开，最后一个元素之后没有空格，并且需要换行

         void print() {
           Node p = head;
           while (p != 0) {
             cout << head->entry;
             if (p->next != 0) cout << ' ';
             else cout << endl;
           }
         }

 

         // 对链表进行归并排序，你可以添加一些辅助函数，但不能改动类的成员变量

         void merge_sort() {
           Node* get_mid(Node *start, Node *end) {
             Node *mid = start;
             while (start != end) {
               start = start->next;
               if (mid->next != end && mid->next != 0) mid = mid->next->next;
             }
             return mid;
           }
           Node* merge(Node *s, Node *m) {
             
           }
           Node* ms(Node *start, Node *end) {
             if (start == end) return;
             Node *mid = get_mid(start, end), *s = start, *t = end;
             ms(s, mid);
             ms(mid, t);
             merge()
           }
         }

private:

         Node<Record> *head;                                     // 链表头指针

};